"""
script to determine git subcommands and gnerate a header file containing the constExpr strings and store the current git version.
"""

import subprocess
import os



def get_git_info():
    # Determine the git version
    version_output = subprocess.run( "git --version" , capture_output=True, shell=True, text=True).stdout
    GIT_VERSION = version_output.split(" ")[-1].strip()

    #Fetch list of commands and parse that 
    git_subcommand_output  = subprocess.run("git --list-cmds=main", capture_output=True, shell=True, text=True).stdout

    return (GIT_VERSION, list(filter(lambda s: len(s) > 0, git_subcommand_output.split(os.linesep))),)


def generate_header_content(GIT_VERSION, SUBCOMMANDS):
    """
    Generate a C++ header file 
    """

    header_content = f"""\
    // AUTO-GENERATED BY THE UPDATER. DO NOT EDIT 
    // GIT VERSION AT THE TIME OF GENERATION: "{GIT_VERSION}"

    #pragma once
    #include <string>
    #include <array>

    const std::string git_version{{"{GIT_VERSION}"}};

    // All sub comands for git version {GIT_VERSION}
    constexpr std::array<std::string_view, {len(SUBCOMMANDS)}> commands = {{{''.join(f'{chr(9)}"{sub}",{os.linesep}' for sub in SUBCOMMANDS)}
        }};
    
    """

    return header_content


def write_to_file(header_content):
    file = os.path.join("include/", "commands_list.h")

    with open(file, 'w+', encoding="utf-8") as f:
        f.write(header_content)
        f.close()



if __name__ == "__main__":
    GIT_VERSION, SUBCOMMANDS = get_git_info()

    write_to_file(generate_header_content(GIT_VERSION, SUBCOMMANDS))


